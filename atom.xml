<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天秤座</title>
  
  <subtitle>libra</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-04T03:38:03.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>colin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>String之intern函数</title>
    <link href="http://yoursite.com/2018/03/04/String%E4%B9%8Bintern%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/03/04/String之intern函数/</id>
    <published>2018-03-04T03:36:18.000Z</published>
    <updated>2018-03-04T03:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>在讲解正式内容前，先来看看JVM的内存模型，以及1.6和1.7还有1.8的内存模型有什么不同。</p><img src="/2018/03/04/String之intern函数/1.png" title="JVM内存图"><blockquote><p>虚拟机栈里面存放的就是一个一个的栈帧（栈帧是用来存储数据和存储部分过程结果的数据结构），而且只有一个活跃的栈帧，也就是栈顶元素</p><p>本地方法栈根据名字就知道他是为本地方法服务的（本地方法只是用java语言定义了，但是具体实现可能就是别的语言了）,他里面存放的就是本地方法帧，用于调用执行本地方法</p><p>程序计数器里面存放的内容可以理解为当前字节码的执行地址，用以完成分支，循环，跳转，异常处理，线程恢复等基础功能</p><p>堆内存：图1所画的是1.6时候的，这时堆中还只有新生代和老年代，新生代占1/3，老年代占2/3，Eden占新生代的8/10（所以新生代实际有效空间为9/10）</p><p>方法区：方法区是堆的逻辑组成部分，用来存放类的基础信息，可以分为以下几类，运行时常量，域信息，方法信息，静态变量等信息。</p></blockquote><p>同时通过上面的图我们可以看到：虚拟机栈，本地方法栈，程序计数器都是线程私有的，而堆和方法区是线程共有的。</p><hr><p>在1.6中PermGen（永久代）存放在方法区中<br>在1.7中PermGen（永久代）中的符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。<br>在1.8中方法区已经没有了，出来了一个Metaspace（元空间），其实和永久代一样，都是对方法区的实现，但是元空间已经不在JVM虚拟机里面了，而是在虚拟机外面的内存空间</p><blockquote><p>那么为什么要移除方法区呢？个人认为是方法区是在启动时确认的，这样会照成内存溢出，而且永久代的回收实现相对比较麻烦</p></blockquote><hr><p>终于可以讲正式内容了</p><p>首先看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String s1 = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">       s1.intern();</span><br><span class="line">       String s2 = <span class="string">"1"</span>;</span><br><span class="line">       System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">       String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">       s3.intern();</span><br><span class="line">       String s4 = <span class="string">"11"</span>;</span><br><span class="line">       System.out.println(s3 == s4);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdk6 下<span class="keyword">false</span> <span class="keyword">false</span></span><br><span class="line">jdk7 下<span class="keyword">false</span> <span class="keyword">true</span></span><br><span class="line">jdk8 下<span class="keyword">false</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure><img src="/2018/03/04/String之intern函数/2.png" title="1.6内存图"><blockquote><p>第一行，new String（“1”）会现在String常量池里面创建一个1的常量，然后在堆里面创建一个String对象，内容指向常量池中的1，然后s1只想堆中对象</p><p>第二行，s1.intern的作用的去常量池里面查看有没有1这个变量，如果没有的话创建</p><p>第三行String s2 = “1”这种创建方法，会直接让s2指向常量池中的1</p><p>第四行，因为s1指向的是堆中地址，s2指向的是常量池中地址，所以肯定为false</p><p>第五行首先和第一行一样，创建两个匿名对象，然后在堆内存中创建一个String对象，对象的值为11，然后让s3指向这个对象</p><p>第六行，查看常量池没有11，创建，并让堆中对象指向该地址</p><p>第七行，s4指向常量池中11</p><p>第八行，因为s3指向的是堆中地址，s4指向的是常量池中地址，所以为false</p></blockquote><p>那么为什么1.7和1.8输出为true呢？这就是内存模型改变照成的</p><img src="/2018/03/04/String之intern函数/3.png" title="1.7内存图"><blockquote><p>注意看箭头指向</p><p>前面已经说过，在1.6以后，已经把一部分内容移动到了heap中，而String poll就放到了堆中，那么既然都在堆中，没必要创建两份对象吧？</p><p>所以第六行的改变就变成了，查看String poll中没有11这个变量，然后就在常量池中开辟一片空间，然后让他指向堆内存的对象（这样一个堆里面，同样的对象只存在一个，别的都是引用）</p><p>所以第八行就成了，s3的值为堆中地址，s4也为堆中地址，所以为true</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在讲解正式内容前，先来看看JVM的内存模型，以及1.6和1.7还有1.8的内存模型有什么不同。&lt;/p&gt;
&lt;img src=&quot;/2018/03/04/String之intern函数/1.png&quot; title=&quot;JVM内存图&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机栈里面存放
      
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java值传递和引用传递</title>
    <link href="http://yoursite.com/2018/01/23/java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2018/01/23/java值传递和引用传递/</id>
    <published>2018-01-23T06:09:58.000Z</published>
    <updated>2018-01-23T07:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道面试题<br>之前被问到过，但是过后也没好好想想，今天有朋友问到这个，查过资料以后总结下<br>先看一段代码：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"A"</span>;  </span><br><span class="line">        change(str);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        </span><br><span class="line">        Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        changeb(i);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">        changed(j);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        </span><br><span class="line">        Stu stu = <span class="keyword">new</span> Stu(<span class="string">"colin"</span>);</span><br><span class="line">        changec(stu);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">(Integer j)</span> </span>&#123;</span><br><span class="line">        j = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changec</span><span class="params">(Stu stu)</span> </span>&#123;</span><br><span class="line">        stu.name = <span class="string">"libra"</span>;</span><br><span class="line"><span class="comment">//        stu = new Stu("libra");</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeb</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">        i = <span class="keyword">new</span> Integer(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stu&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p></p><h5>结果</h5><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">Stu&#123;name=<span class="string">'wtx'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><h5>个人理解：</h5><br>java中传递方式分为值传递和引用传递<br>值传递：基本类型(byte–short–int–long–float–double–boolean–char)<br>引用传递：类类型，接口类型，数组<p></p><p></p><h6>例子一：String</h6><br><img src="/2018/01/23/java值传递和引用传递/1.png" title="java内存图"><br>String是在常量池中的，这些无所谓，有所谓的是引用传递传递的是地址，A的地址是0x1101现在把0x1101传递过去，让实参str接受，这时候str也指向了0x1101，这时候修改实参str的指向，只是修改了实参的指向，没有修改外面str的指向，所有输出为A<p></p><p></p><h6>例子二：Integer，Double包装类</h6><br>这些包装类里面没有修改值的操作，而且是final类型的，所以我们修改值的时候不是在原来的基础上修改，所以输出10<p></p><p></p><h6>例子三：基本类型</h6><br>基本类型就是值传递，不涉及引用，不修改外面值<p></p><p></p><h6>例子四：修改对象值</h6><br>对于例子四，如果使用第一行代码的话，我们是在原对象中修改，故会改变外面的值，但是如果我们是用第二种，那只是改变了内部引用，不影响外面值的变化<p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道面试题&lt;br&gt;之前被问到过，但是过后也没好好想想，今天有朋友问到这个，查过资料以后总结下&lt;br&gt;先看一段代码：&lt;br&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>自定义线程池（二）</title>
    <link href="http://yoursite.com/2017/12/11/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/12/11/自定义线程池（二）/</id>
    <published>2017-12-11T09:38:30.000Z</published>
    <updated>2018-03-06T09:42:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇已经讲过一些线程池的概念，现在我们来自定义一个线程池，实现的不是一般，就是一个个人理解的线程池实现，仅供参考。</p><ol><li><p>创建变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程状态，空闲，运行中，阻塞，结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> WorkerState &#123;FREE, RUNNABLE, BLOCKED,TERMINATED;&#125;</span><br><span class="line"><span class="comment">// 线程池是否被销毁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroy = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CORE_THREAD_SIZE = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THREAD_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 任务队列容器,也可以用Queue&lt;Runnable&gt; 遵循 FIFO 规则</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> LinkedList&lt;Runnable&gt; TASK_QUEUE = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// 设置它的边界值为11</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TASK_QUEUE_MAX_SIZE = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 线程容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Worker&gt; WORKERS = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><ol><li>WorkerState：线程状态，一个线程新创建的时候为FREE，工作的时候为RUNNABLE，处于阻塞状态的时候为BLOCK（意味着当前任务队列没有任务了），而TERMINATED表示当前线程结束</li><li>destroy：线程池状态，表示当前线程是否已经销毁，只有执行了shutdown方法才会销毁线程池，并发情况下要保证可见性</li><li>TASK_QUEUE_MAX_SIZE：任务阻塞队列的边界值</li></ol></blockquote></li><li><p>编写submit方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destroy) &#123;</span><br><span class="line">        System.out.println(<span class="string">"线程池已经销毁了，抛出异常！这里用日志代替"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (TASK_QUEUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WORKERS.size() &lt; CORE_THREAD_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">"核心线程数还没有满，直接创建线程"</span>);</span><br><span class="line">            createWorkerTask();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TASK_QUEUE.size() &lt; TASK_QUEUE_MAX_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">"核心线程数已满，但是队列没有满，把任务加到队列"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WORKERS.size() &lt; MAX_THREAD_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">"核心线程数,队列满了，但是没有达到最大线程数，我们接着创建线程"</span>);</span><br><span class="line">            createWorkerTask();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WORKERS.size() &gt;= MAX_THREAD_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">"达到了最大线程数，应该执行拒绝策略，这里我们就直接返回了"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"情况未知"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入任务队列</span></span><br><span class="line">        TASK_QUEUE.addLast(runnable);</span><br><span class="line">        <span class="comment">// 唤醒所有线程</span></span><br><span class="line">        TASK_QUEUE.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>没有一个任务，我们都是通过submit交给线程池去处理的，先判断是否达到核心线程数，没有的话直接创建，如果核心线程数满了，就往队列里加，队列也满了就新建线程，如果达到最大线程数，就拒绝，这里有一点改变就是不管哪一种，我们都把人物放到任务队列中，让线程去任务队列里面取。</p></blockquote></li><li><p>创建线程方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void createWorkerTask() &#123;</span><br><span class="line">    Worker worker = new Worker();</span><br><span class="line">    worker.workerState = WorkerState.FREE;</span><br><span class="line">    WORKERS.add(worker);</span><br><span class="line">    worker.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程创建之初，为空闲状态，并添加进线程集合中</p></blockquote></li><li><p>创建线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WorkerState workerState;</span><br><span class="line">    <span class="comment">// 线程编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line">    <span class="comment">// 生成线程名</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> String <span class="title">nextThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread-"</span> + (++threadInitNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    Worker() &#123;</span><br><span class="line">        nextThreadName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启了一个新的线程------&gt;"</span> + threadInitNumber);</span><br><span class="line">        Runnable targer;</span><br><span class="line">        OUTER:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.workerState != WorkerState.TERMINATED) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TASK_QUEUE) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.workerState == WorkerState.FREE &amp;&amp; TASK_QUEUE.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.workerState = WorkerState.BLOCKED;</span><br><span class="line">                        TASK_QUEUE.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">break</span> OUTER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                targer = TASK_QUEUE.removeFirst();</span><br><span class="line">                System.out.println(<span class="string">"处理任务"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.workerState = WorkerState.RUNNABLE;</span><br><span class="line">                targer.run();</span><br><span class="line">                <span class="keyword">this</span>.workerState = WorkerState.FREE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerState = WorkerState.TERMINATED;</span><br><span class="line">        <span class="keyword">this</span>.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了方便观看，我们给线程指定编号，如果当前线程没有关闭的话，先去判断队列是否为空且本身的状态是空闲的话，我们就让他wait，等新来的任务再去唤醒，如果获取到了我们就处理这个任务，并把他从队列的头部拿出来</p></blockquote></li><li><p>关闭线程池方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = WORKERS.size();</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : WORKERS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (worker.workerState == WorkerState.BLOCKED) &#123;</span><br><span class="line">                worker.close();</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.destroy = <span class="keyword">true</span>;</span><br><span class="line">    TASK_QUEUE.clear();</span><br><span class="line">    WORKERS.clear();</span><br><span class="line">    System.out.println(<span class="string">"线程池已经关闭！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>等所有线程的任务都完成了以后才关闭线程，同时把线程池状态标记为销毁，并清空任务队列和线程集合。</p></blockquote></li><li><p>使用run()来控制释放线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!destroy) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (WORKERS) &#123;</span><br><span class="line">                Iterator&lt;Worker&gt; iterator = WORKERS.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    Worker worker = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (WORKERS.size() &gt; CORE_THREAD_SIZE &amp;&amp; </span><br><span class="line">                        TASK_QUEUE.size() &lt; TASK_QUEUE_MAX_SIZE) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (worker.workerState != WorkerState.RUNNABLE &amp;&amp; worker.workerState != WorkerState.TERMINATED) &#123;</span><br><span class="line">                            worker.close();</span><br><span class="line">                            iterator.remove();</span><br><span class="line">                            System.out.println(<span class="string">"[回收了一个线程]"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每隔3秒去遍历一下所有的线程，如果线程数大于核心线程数，且任务队列不满的话，就删除线程，知道和核心线程数一样</p></blockquote></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    DemoThreadPool demoThreadPool = <span class="keyword">new</span> DemoThreadPool();</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">5</span>).forEach(i -&gt;</span><br><span class="line">            demoThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.printf(<span class="string">"[线程] - [%s] 开始工作...\n"</span>,        </span><br><span class="line">                                  Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2_000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">"[线程] - [%s] 工作完毕...\n"</span>, </span><br><span class="line">                                  Thread.currentThread().getName());</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">30</span>).forEach(i -&gt;</span><br><span class="line">            demoThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.printf(<span class="string">"[线程] - [%s] 开始工作...\n"</span>, </span><br><span class="line">                                  Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2_000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">"[线程] - [%s] 工作完毕...\n"</span>, </span><br><span class="line">                                  Thread.currentThread().getName());</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line"><span class="comment">//        demoThreadPool.shutdown();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了观察状态，我们先一下子创建5个任务，这个时候他会先创建2个线程，然后把3个放到队列里，因为没有满，所以这两个线程就可以应付，但是当一下30个的时候，会发生拒绝，然后过了峰值以后，多余的线程就会销毁。</p></blockquote><p>实现的可能不好，但是我理解的就是这样，源码在<a href="https://github.com/colin-xun/threadpool上，欢迎给我点:star" target="_blank" rel="noopener">https://github.com/colin-xun/threadpool上，欢迎给我点:star</a>:</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇已经讲过一些线程池的概念，现在我们来自定义一个线程池，实现的不是一般，就是一个个人理解的线程池实现，仅供参考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建变量&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="java高级" scheme="http://yoursite.com/categories/java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>自定义线程池（一）</title>
    <link href="http://yoursite.com/2017/12/09/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/12/09/自定义线程池（一）/</id>
    <published>2017-12-09T08:17:23.000Z</published>
    <updated>2018-03-05T10:15:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们自定义线程池之前，先预备一点前置知识</p><ul><li>为什么要使用线程池？</li></ul><ol><li>New Thread这种方式性能差</li><li>缺乏统一管理，循环创建会照成OOM</li><li>功能单一</li></ol><p>对应的就是线程池的优点，JAVA1.5出来的Concurrent包里面提供了四种创建线程池的方法，我们可以直接创建，但阿里Java开发手册有这么一条</p><blockquote><p>【强制】线程池不允许使用 Executors 去创建，而是通过ThreadPoolExecutor 的方式</p></blockquote><p>这样的好处就强制开发者去了解线程池的创建原理，从而避免资源耗尽的风险，而且Executors中四种线程池创建方式其实都依赖于ThreadPollExecutor这个类的构造。</p><ul><li>线程池概念</li></ul><img src="/2017/12/09/自定义线程池（一）/1.png" title="关系图"><p>从图中可以看到各个类和接口的关系，同时可以看到Executors和其他类或接口没有什么直接关系，我们可以把他当成一个线程池工厂，用来创建四种线程池。</p><p>先说下ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>corePoolSize：核心线程数大小</p><p>maximumPoolSize：线程池最大线程数</p><p>keepAliveTime：当线程数大于核心时，清除空闲keepAliveTime时间的线程</p><p>unit：时间单位</p><p>workQueue：存储等待任务的队列</p><p>threadFactory：线程工厂</p><p>handler：拒绝策略</p></blockquote><p>刚创建的线程池是没有任何线程的，当过来一个任务，就启动一个线程去执行，再过来一个还创建一个新的线程，即便之前的已经空闲了，当线程池达到核心线程数的话，如果没有空闲线程，就把新加进来的任务放到阻塞队列，如果阻塞队列是有边界的话，到达边界以后就会去创建新的线程，接下来就会出现两种情况：</p><ol><li>如果任务不再来了，那么就会把空闲keepAliveTime时间的线程给移除掉</li><li>如果任务接着来，并且已经达到了最大线程数，那么就要执行拒绝策略了</li></ol><p>其中等待队列有多种ArrayBlockingQueue，LinkedBlockingQueue，LinkedBlockingDeque，SynchronousQueue，根据具体情况而定。</p><p>拒绝策略也有很多种</p><ol><li>AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。 (默认)</li><li>DiscardPolicy：也是丢弃任务，但是不抛出异常。</li><li>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>CallerRunsPolicy：由调用线程处理该任务</li></ol><ul><li>四种创建线程池的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建一个单线程，你看名字里面都没有ThreadPool:smile:，如果这个线程死了，他会创建一个新的线程来替代。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个线程的特点从等待队列就可以看出来，这个队列根本不存储数据，只是做一个通道，一边进一边出。最大线程数为Integer.MAX_VALUE,也就是过来一个任务我就创建一个线程，当线程数大于任务数的时候就去回收那些空闲超过60秒的线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        nThreads, nThreads,</span><br><span class="line">    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个线程池核心线程和最大线程数相等，也就是说，过来一个任务，就直接创建一个线程，等到了最大线程数，你看keepAliveTime为0，所以就是不管线程使用不适用都不回收，如果线程挂了的话会重新创建一个。为了不然频繁丢弃任务，这里使用了一个无界链表队列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(</span><br><span class="line">          corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">      <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个线程池的特点从名字就可以看出来，定期线程池，也就是任务会定期执行，这个定期是在他调用schedule方法的时候，就像一个Timer定时器一样，而他的实现主要是靠DelayedWorkQueue这个延迟队列，他规定只有到达规定延迟时间以后才能获取里面的元素</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我们自定义线程池之前，先预备一点前置知识&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么要使用线程池？&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;New Thread这种方式性能差&lt;/li&gt;
&lt;li&gt;缺乏统一管理，循环创建会照成OOM&lt;/li&gt;
&lt;li&gt;功能单一&lt;/li&gt;
&lt;/ol&gt;
&lt;
      
    
    </summary>
    
      <category term="java高级" scheme="http://yoursite.com/categories/java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>session共享解决方案</title>
    <link href="http://yoursite.com/2017/10/09/session%E5%85%B1%E4%BA%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/10/09/session共享解决方案/</id>
    <published>2017-10-09T05:43:54.000Z</published>
    <updated>2018-03-09T05:48:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>用户通过浏览器访问服务器的时候，服务器会自动产生session，用来存放用户信息，登录信息等内容，在分布式的系统中，如何保证session的一致性呢？</p><ul><li><p>方法一：session同步</p><p>这个很好解释，也就是每新生成一个session，我们都把他同步到所有的服务器上面，这样每台服务器都有所有用户的session了，这是一种解决方法</p><p>优点：实现思路简单</p><p>缺点：  </p><ol><li>占用带宽，也就是每次都要去同步session，当服务器多的时候情况会很明显</li><li>占用内存，每台服务器都要存储所有的session，当session多的时候情况会很明显</li></ol></li><li><p>方法二：客户端存储</p><p>用客户端来存放用户信息，登录信息等内容，下次请求的时候携带过来就行了，也是一种实现方法</p><p>优点：服务端不用存储</p><p>缺点：</p><ol><li>安全性下降：cookie容易被窃取</li><li>存储数据量小，不同浏览器允许的cookie大小有限。</li></ol></li><li><p>方法三：一致性hash</p><p>使用一致性hash算法计算出每个session存放的服务器，例如使用IP来做一致性hash，那么这个IP对应的session存放在哪一台服务器就确定了</p><p>优点：</p><ol><li>工作量小，不需要更改代码，只要配置nginx就可以了</li><li>支持水平扩展</li></ol><p>缺点：</p><ol><li>当新水平扩展的时候，要从新计算hash值，用户需要重新登录</li><li>服务器重启，数据丢失</li></ol></li><li><p>方法四：后台统一存储</p><p>把session存放到数据库或缓存中</p><p>优点：</p><ol><li>安全性高：即便重启了数据依然存在</li><li>水平扩展：因为session是单独存储的，所以不影响水平扩展</li></ol><p>缺点：</p><ol><li>代码改动量大：当然如果一开始就使用的话，也是很简单的</li><li>增加了一次服务调用</li></ol></li></ul><p>目前公司在使用的是redis中的session共享，使用redis的好处是速度快而且支持持久化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用户通过浏览器访问服务器的时候，服务器会自动产生session，用来存放用户信息，登录信息等内容，在分布式的系统中，如何保证session的一致性呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法一：session同步&lt;/p&gt;
&lt;p&gt;这个很好解释，也就是每新生成一个session，
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="session" scheme="http://yoursite.com/tags/session/"/>
    
      <category term="一致性" scheme="http://yoursite.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="共享" scheme="http://yoursite.com/tags/%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>树莓派3B-DHT11-Yeelink云平台（实现温湿度远程监控）</title>
    <link href="http://yoursite.com/2015/07/09/%E6%A0%91%E8%8E%93%E6%B4%BE3B-DHT11-Yeelink%E4%BA%91%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%B8%A9%E6%B9%BF%E5%BA%A6%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7%EF%BC%89/"/>
    <id>http://yoursite.com/2015/07/09/树莓派3B-DHT11-Yeelink云平台（实现温湿度远程监控）/</id>
    <published>2015-07-09T02:37:46.000Z</published>
    <updated>2018-03-05T03:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为毕业设计选了个让自己一脸懵逼的题目，听同学说树莓派实现比较简单，所以我就花了4百大洋买了一个3B的板子和一个树莓派原装的摄像头（一百五左右，最后发现网上资料太少了!😭，而且只是搞下毕业设计，就不打算深究了，网上找个例子实现功能就可以了，不过拍的确实清晰）。好了，下面就说下怎么实现云平台实时监控温湿度把。其中有投机取巧的部分。其实我说的所有都只是一种方法，大家可以去尝试别的，下面就不赘述了，直接写过程。</p><ul><li>装系统</li></ul><p>装系统的话，直接去官网下载就行，毕竟用的树莓派，我就下了raspbian，带桌面（毕竟小白）这是下载链接<a href="https://downloads.raspberrypi.org/raspbian_latest" target="_blank" rel="noopener">https://downloads.raspberrypi.org/raspbian_latest</a></p><p>同时需要一个写入工具，我当时应该不是在官网下的，这是链接，速度挺快，下载完解压就行<a href="http://124.202.164.7/files/4125000005975BAB/vzidc.newhua.com/down/Win32DiskImager-0.9.5-binary.zip" target="_blank" rel="noopener">http://124.202.164.7/files/4125000005975BAB/vzidc.newhua.com/down/Win32DiskImager-0.9.5-binary.zip</a></p><p>然后需要一张4g以上的sd卡，反正我用的8g，我用的就是很早以前手机里的内存卡，同时需要一个读卡器，打开读写工具，然后把解压后的img系统文件写入到内存卡，就可以了</p><ul><li>登录树莓派</li></ul><p>第一次登录用ssh工具，首先你需要知道局域网给你的树莓派分配的IP地址，可以使用一个端口扫描工具，看看哪儿22端口是开放的，然后xshell链接</p><ul><li>显示图形界面</li></ul><p>我也不先配置别的了，先让大家看看图形界面吧，上vncviewer下载客户端，然后在xshell输入sudo apt-get install tightvncserver然后等读码完成，然后输入vncserver，接下来它让你设置密码，我设置12345678，然后确认再输入一次，接着打开vncviewer，在地址栏输入树莓派ip:1回车，然后输入12345678，回车就可以看到图形界面了</p><ul><li>树莓派连接上无线网路</li></ul><p>因为树莓派没有自带vim，所以我就先安装了vim，命令式sudo apt-get install vim</p><p>然后sudo vim /etc/network/interfaces 然后修改成下列样式</p><pre><code>auto loiface loinet loopbackifaceeth0 inet dhcpautowlan0allow-hotplugwlan0ifacewlan0 inet dhcp      wpa-ssid 要连入的WiFi名      wpa-psk WiFi密码</code></pre><p>然后sudo /etc/init.d/networking restart 但是这时候会分配一个新的ip，然后xshell创建一个新的连接就行了</p><p>修改配置</p><p>这是树莓派3B的界面，别的修改项含义可以参考</p><p><a href="http://blog.csdn.net/xdw1985829/article/details/38816375" target="_blank" rel="noopener">http://blog.csdn.net/xdw1985829/article/details/38816375</a></p><p>，我修改了第一项，让文件系统覆盖整个sd卡，同时修改了时区，如果不修改时区的话，接下来上传的数据时间不正确</p><p>安装WiringPi</p><p>sudo apt-get install wiringPi 安装完可以测试一下gpio readall然后会显示一些东西就证明可以了</p><p>接下来就是程序和怎么连接到yeelink上了</p><p>下载我整理好的程序，test.c是源文件可以使用gcc编译一下，编译命令式gcc –Wall –o 输出的文件名  编译的文件名 –lwiringPi 然后生成一个你要生成的文件名</p><p>接下来修改shell脚本,Yeelink教程网上很多，我就不介绍了，得到两个传感器的URL就行，还有你的API key，替换成你的API key和URL，同时还有你编译.c生成的文件的路径</p><p>这是我写的，有点投机取巧✌️，勉强能用。</p><p>链接：<a href="http://pan.baidu.com/s/1nuXLmAl" target="_blank" rel="noopener">http://pan.baidu.com/s/1nuXLmAl</a> 密码：yjvq</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为毕业设计选了个让自己一脸懵逼的题目，听同学说树莓派实现比较简单，所以我就花了4百大洋买了一个3B的板子和一个树莓派原装的摄像头（一百五左右，最后发现网上资料太少了!😭，而且只是搞下毕业设计，就不打算深究了，网上找个例子实现功能就可以了，不过拍的确实清晰）。好了，下面就
      
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="树莓派" scheme="http://yoursite.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="温湿度传感器" scheme="http://yoursite.com/tags/%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    
      <category term="毕业设计" scheme="http://yoursite.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>java之char数组输出</title>
    <link href="http://yoursite.com/2015/02/07/java%E4%B9%8Bchar%E6%95%B0%E7%BB%84%E8%BE%93%E5%87%BA/"/>
    <id>http://yoursite.com/2015/02/07/java之char数组输出/</id>
    <published>2015-02-07T02:37:46.000Z</published>
    <updated>2018-03-05T02:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先println方法对数组的处理是先转化为String类型，我们可以进入println源码看一下，我是创建了一个String数组进去看了下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(x);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先他都转化成了String，然后进入print方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        s = <span class="string">"null"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再进入write方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();<span class="comment">//确认输出流是否打开了</span></span><br><span class="line">            textOut.write(s);<span class="comment">//就是一个bufferWriter，写入到缓冲区</span></span><br><span class="line">            textOut.flushBuffer();<span class="comment">//刷新缓存区</span></span><br><span class="line">            charOut.flushBuffer();<span class="comment">//OutputStreamWriter</span></span><br><span class="line">            <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                out.flush();<span class="comment">//这里就是与char数组的却别，他直接把String s刷新到了控制台的输出流中，但是记住他没有和toString方法相关联</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们看看char数组的write方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> buf[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            textOut.write(buf);</span><br><span class="line">            textOut.flushBuffer();</span><br><span class="line">            charOut.flushBuffer();</span><br><span class="line">            <span class="keyword">if</span> (autoFlush) &#123;<span class="comment">//我们可以看到，他是把每个字符都写入到了控制台的输出流了。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.length; i++)</span><br><span class="line">                    <span class="keyword">if</span> (buf[i] == <span class="string">'\n'</span>)</span><br><span class="line">                        out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这是第二次遇到这问题了，但是之前没有非常明白，这里弄清楚记录一下，也供大家参考一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先println方法对数组的处理是先转化为String类型，我们可以进入println源码看一下，我是创建了一个String数组进去看了下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
