<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天秤座</title>
  
  <subtitle>libra</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-04T03:38:03.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>colin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>String之intern函数</title>
    <link href="http://yoursite.com/2018/03/04/String%E4%B9%8Bintern%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/03/04/String之intern函数/</id>
    <published>2018-03-04T03:36:18.000Z</published>
    <updated>2018-03-04T03:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>在讲解正式内容前，先来看看JVM的内存模型，以及1.6和1.7还有1.8的内存模型有什么不同。</p><img src="/2018/03/04/String之intern函数/1.png" title="JVM内存图"><blockquote><p>虚拟机栈里面存放的就是一个一个的栈帧（栈帧是用来存储数据和存储部分过程结果的数据结构），而且只有一个活跃的栈帧，也就是栈顶元素</p><p>本地方法栈根据名字就知道他是为本地方法服务的（本地方法只是用java语言定义了，但是具体实现可能就是别的语言了）,他里面存放的就是本地方法帧，用于调用执行本地方法</p><p>程序计数器里面存放的内容可以理解为当前字节码的执行地址，用以完成分支，循环，跳转，异常处理，线程恢复等基础功能</p><p>堆内存：图1所画的是1.6时候的，这时堆中还只有新生代和老年代，新生代占1/3，老年代占2/3，Eden占新生代的8/10（所以新生代实际有效空间为9/10）</p><p>方法区：方法区是堆的逻辑组成部分，用来存放类的基础信息，可以分为以下几类，运行时常量，域信息，方法信息，静态变量等信息。</p></blockquote><p>同时通过上面的图我们可以看到：虚拟机栈，本地方法栈，程序计数器都是线程私有的，而堆和方法区是线程共有的。</p><hr><p>在1.6中PermGen（永久代）存放在方法区中<br>在1.7中PermGen（永久代）中的符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。<br>在1.8中方法区已经没有了，出来了一个Metaspace（元空间），其实和永久代一样，都是对方法区的实现，但是元空间已经不在JVM虚拟机里面了，而是在虚拟机外面的内存空间</p><blockquote><p>那么为什么要移除方法区呢？个人认为是方法区是在启动时确认的，这样会照成内存溢出，而且永久代的回收实现相对比较麻烦</p></blockquote><hr><p>终于可以讲正式内容了</p><p>首先看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String s1 = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">       s1.intern();</span><br><span class="line">       String s2 = <span class="string">"1"</span>;</span><br><span class="line">       System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">       String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">       s3.intern();</span><br><span class="line">       String s4 = <span class="string">"11"</span>;</span><br><span class="line">       System.out.println(s3 == s4);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdk6 下<span class="keyword">false</span> <span class="keyword">false</span></span><br><span class="line">jdk7 下<span class="keyword">false</span> <span class="keyword">true</span></span><br><span class="line">jdk8 下<span class="keyword">false</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure><img src="/2018/03/04/String之intern函数/2.png" title="1.6内存图"><blockquote><p>第一行，new String（“1”）会现在String常量池里面创建一个1的常量，然后在堆里面创建一个String对象，内容指向常量池中的1，然后s1只想堆中对象</p><p>第二行，s1.intern的作用的去常量池里面查看有没有1这个变量，如果没有的话创建</p><p>第三行String s2 = “1”这种创建方法，会直接让s2指向常量池中的1</p><p>第四行，因为s1指向的是堆中地址，s2指向的是常量池中地址，所以肯定为false</p><p>第五行首先和第一行一样，创建两个匿名对象，然后在堆内存中创建一个String对象，对象的值为11，然后让s3指向这个对象</p><p>第六行，查看常量池没有11，创建，并让堆中对象指向该地址</p><p>第七行，s4指向常量池中11</p><p>第八行，因为s3指向的是堆中地址，s4指向的是常量池中地址，所以为false</p></blockquote><p>那么为什么1.7和1.8输出为true呢？这就是内存模型改变照成的</p><img src="/2018/03/04/String之intern函数/3.png" title="1.7内存图"><blockquote><p>注意看箭头指向</p><p>前面已经说过，在1.6以后，已经把一部分内容移动到了heap中，而String poll就放到了堆中，那么既然都在堆中，没必要创建两份对象吧？</p><p>所以第六行的改变就变成了，查看String poll中没有11这个变量，然后就在常量池中开辟一片空间，然后让他指向堆内存的对象（这样一个堆里面，同样的对象只存在一个，别的都是引用）</p><p>所以第八行就成了，s3的值为堆中地址，s4也为堆中地址，所以为true</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在讲解正式内容前，先来看看JVM的内存模型，以及1.6和1.7还有1.8的内存模型有什么不同。&lt;/p&gt;
&lt;img src=&quot;/2018/03/04/String之intern函数/1.png&quot; title=&quot;JVM内存图&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机栈里面存放
      
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java值传递和引用传递</title>
    <link href="http://yoursite.com/2018/01/23/java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2018/01/23/java值传递和引用传递/</id>
    <published>2018-01-23T06:09:58.000Z</published>
    <updated>2018-01-23T07:08:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道面试题<br>之前被问到过，但是过后也没好好想想，今天有朋友问到这个，查过资料以后总结下<br>先看一段代码：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"A"</span>;  </span><br><span class="line">        change(str);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        </span><br><span class="line">        Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        changeb(i);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">        changed(j);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        </span><br><span class="line">        Stu stu = <span class="keyword">new</span> Stu(<span class="string">"colin"</span>);</span><br><span class="line">        changec(stu);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">(Integer j)</span> </span>&#123;</span><br><span class="line">        j = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changec</span><span class="params">(Stu stu)</span> </span>&#123;</span><br><span class="line">        stu.name = <span class="string">"libra"</span>;</span><br><span class="line"><span class="comment">//        stu = new Stu("libra");</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeb</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">        i = <span class="keyword">new</span> Integer(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stu&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p></p><h5>结果</h5><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">Stu&#123;name=<span class="string">'wtx'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><h5>个人理解：</h5><br>java中传递方式分为值传递和引用传递<br>值传递：基本类型(byte–short–int–long–float–double–boolean–char)<br>引用传递：类类型，接口类型，数组<p></p><p></p><h6>例子一：String</h6><br><img src="/2018/01/23/java值传递和引用传递/1.png" title="java内存图"><br>String是在常量池中的，这些无所谓，有所谓的是引用传递传递的是地址，A的地址是0x1101现在把0x1101传递过去，让实参str接受，这时候str也指向了0x1101，这时候修改实参str的指向，只是修改了实参的指向，没有修改外面str的指向，所有输出为A<p></p><p></p><h6>例子二：Integer，Double包装类</h6><br>这些包装类里面没有修改值的操作，而且是final类型的，所以我们修改值的时候不是在原来的基础上修改，所以输出10<p></p><p></p><h6>例子三：基本类型</h6><br>基本类型就是值传递，不涉及引用，不修改外面值<p></p><p></p><h6>例子四：修改对象值</h6><br>对于例子四，如果使用第一行代码的话，我们是在原对象中修改，故会改变外面的值，但是如果我们是用第二种，那只是改变了内部引用，不影响外面值的变化<p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道面试题&lt;br&gt;之前被问到过，但是过后也没好好想想，今天有朋友问到这个，查过资料以后总结下&lt;br&gt;先看一段代码：&lt;br&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>自定义线程池（一）</title>
    <link href="http://yoursite.com/2017/12/09/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/12/09/自定义线程池（一）/</id>
    <published>2017-12-09T08:17:23.000Z</published>
    <updated>2018-03-05T08:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们自定义线程池之前，先预备一点前置知识</p><ul><li>为什么要使用线程池？</li></ul><ol><li>New Thread这种方式性能差</li><li>缺乏统一管理，循环创建会照成OOM</li><li>功能单一</li></ol><p>对应的就是线程池的优点，JAVA1.5出来的Concurrent包里面提供了四种创建线程池的方法，我们可以直接创建，但阿里Java开发手册有这么一条</p><blockquote><p>【强制】线程池不允许使用 Executors 去创建，而是通过ThreadPoolExecutor 的方式</p></blockquote><p>这样的好处就强制开发者去了解线程池的创建原理，从而避免资源耗尽的风险，而且Executors中四种线程池创建方式其实都依赖于ThreadPollExecutor这个类的构造。</p><ul><li>线程池概念</li></ul><img src="/2017/12/09/自定义线程池（一）/1.png" title="关系图"><p>从图中可以看到各个类和接口的关系，同时可以看到Executors和其他类或接口没有什么直接关系，我们可以把他当成一个线程池工厂，用来创建四种线程池。</p><p>先说下ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>corePoolSize：核心线程数大小</p><p>maximumPoolSize：线程池最大线程数</p><p>keepAliveTime：当线程数大于核心时，清除空闲keepAliveTime时间的线程</p><p>unit：时间单位</p><p>workQueue：存储等待任务的队列</p><p>threadFactory：线程工厂</p><p>handler：拒绝策略</p></blockquote><p>刚创建的线程池是没有任何线程的，当过来一个任务，就启动一个线程去执行，当线程池达到核心线程数的话，就把新加进来的任务放到阻塞队列，如果阻塞队列是有边界的话，到达边界以后就会去创建新的线程，接下来就会出现两种情况：</p><ol><li>如果任务不再来了，那么就会把空闲keepAliveTime时间的线程给移除掉</li><li>如果任务接着来，并且已经达到了最大线程数，那么就要执行拒绝策略了</li></ol><p>其中等待队列有多种ArrayBlockingQueue，LinkedBlockingQueue，LinkedBlockingDeque，SynchronousQueue，根据具体情况而定。</p><p>拒绝策略也有很多种</p><ol><li>AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。 (默认)</li><li>DiscardPolicy：也是丢弃任务，但是不抛出异常。</li><li>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>CallerRunsPolicy：由调用线程处理该任务</li></ol><ul><li>四种创建线程池的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建一个单线程，你看名字里面都没有ThreadPool:smile:，如果这个线程死了，他会创建一个新的线程来替代。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个线程的特点从等待队列就可以看出来，这个队列根本不存储数据，只是做一个通道，一边进一边出。最大线程数为Integer.MAX_VALUE,也就是过来一个任务我就创建一个线程，当线程数大于任务数的时候就去回收那些空闲超过60秒的线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        nThreads, nThreads,</span><br><span class="line">    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个线程池核心线程和最大线程数相等，也就是说，过来一个任务，就直接创建一个线程，等到了最大线程数，你看keepAliveTime为0，所以就是不管线程使用不适用都不回收，如果线程挂了的话会重新创建一个。为了不然频繁丢弃任务，这里使用了一个无界链表队列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(</span><br><span class="line">          corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">      <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个线程池的特点从名字就可以看出来，定期线程池，也就是任务会定期执行，这个定期是在他调用schedule方法的时候，就像一个Timer定时器一样，而他的实现主要是靠DelayedWorkQueue这个延迟队列，他规定只有到达规定延迟时间以后才能获取里面的元素</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我们自定义线程池之前，先预备一点前置知识&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么要使用线程池？&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;New Thread这种方式性能差&lt;/li&gt;
&lt;li&gt;缺乏统一管理，循环创建会照成OOM&lt;/li&gt;
&lt;li&gt;功能单一&lt;/li&gt;
&lt;/ol&gt;
&lt;
      
    
    </summary>
    
      <category term="java高级" scheme="http://yoursite.com/categories/java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>树莓派3B-DHT11-Yeelink云平台（实现温湿度远程监控）</title>
    <link href="http://yoursite.com/2015/07/09/%E6%A0%91%E8%8E%93%E6%B4%BE3B-DHT11-Yeelink%E4%BA%91%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%B8%A9%E6%B9%BF%E5%BA%A6%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7%EF%BC%89/"/>
    <id>http://yoursite.com/2015/07/09/树莓派3B-DHT11-Yeelink云平台（实现温湿度远程监控）/</id>
    <published>2015-07-09T02:37:46.000Z</published>
    <updated>2018-03-05T03:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为毕业设计选了个让自己一脸懵逼的题目，听同学说树莓派实现比较简单，所以我就花了4百大洋买了一个3B的板子和一个树莓派原装的摄像头（一百五左右，最后发现网上资料太少了!😭，而且只是搞下毕业设计，就不打算深究了，网上找个例子实现功能就可以了，不过拍的确实清晰）。好了，下面就说下怎么实现云平台实时监控温湿度把。其中有投机取巧的部分。其实我说的所有都只是一种方法，大家可以去尝试别的，下面就不赘述了，直接写过程。</p><ul><li>装系统</li></ul><p>装系统的话，直接去官网下载就行，毕竟用的树莓派，我就下了raspbian，带桌面（毕竟小白）这是下载链接<a href="https://downloads.raspberrypi.org/raspbian_latest" target="_blank" rel="noopener">https://downloads.raspberrypi.org/raspbian_latest</a></p><p>同时需要一个写入工具，我当时应该不是在官网下的，这是链接，速度挺快，下载完解压就行<a href="http://124.202.164.7/files/4125000005975BAB/vzidc.newhua.com/down/Win32DiskImager-0.9.5-binary.zip" target="_blank" rel="noopener">http://124.202.164.7/files/4125000005975BAB/vzidc.newhua.com/down/Win32DiskImager-0.9.5-binary.zip</a></p><p>然后需要一张4g以上的sd卡，反正我用的8g，我用的就是很早以前手机里的内存卡，同时需要一个读卡器，打开读写工具，然后把解压后的img系统文件写入到内存卡，就可以了</p><ul><li>登录树莓派</li></ul><p>第一次登录用ssh工具，首先你需要知道局域网给你的树莓派分配的IP地址，可以使用一个端口扫描工具，看看哪儿22端口是开放的，然后xshell链接</p><ul><li>显示图形界面</li></ul><p>我也不先配置别的了，先让大家看看图形界面吧，上vncviewer下载客户端，然后在xshell输入sudo apt-get install tightvncserver然后等读码完成，然后输入vncserver，接下来它让你设置密码，我设置12345678，然后确认再输入一次，接着打开vncviewer，在地址栏输入树莓派ip:1回车，然后输入12345678，回车就可以看到图形界面了</p><ul><li>树莓派连接上无线网路</li></ul><p>因为树莓派没有自带vim，所以我就先安装了vim，命令式sudo apt-get install vim</p><p>然后sudo vim /etc/network/interfaces 然后修改成下列样式</p><pre><code>auto loiface loinet loopbackifaceeth0 inet dhcpautowlan0allow-hotplugwlan0ifacewlan0 inet dhcp      wpa-ssid 要连入的WiFi名      wpa-psk WiFi密码</code></pre><p>然后sudo /etc/init.d/networking restart 但是这时候会分配一个新的ip，然后xshell创建一个新的连接就行了</p><p>修改配置</p><p>这是树莓派3B的界面，别的修改项含义可以参考</p><p><a href="http://blog.csdn.net/xdw1985829/article/details/38816375" target="_blank" rel="noopener">http://blog.csdn.net/xdw1985829/article/details/38816375</a></p><p>，我修改了第一项，让文件系统覆盖整个sd卡，同时修改了时区，如果不修改时区的话，接下来上传的数据时间不正确</p><p>安装WiringPi</p><p>sudo apt-get install wiringPi 安装完可以测试一下gpio readall然后会显示一些东西就证明可以了</p><p>接下来就是程序和怎么连接到yeelink上了</p><p>下载我整理好的程序，test.c是源文件可以使用gcc编译一下，编译命令式gcc –Wall –o 输出的文件名  编译的文件名 –lwiringPi 然后生成一个你要生成的文件名</p><p>接下来修改shell脚本,Yeelink教程网上很多，我就不介绍了，得到两个传感器的URL就行，还有你的API key，替换成你的API key和URL，同时还有你编译.c生成的文件的路径</p><p>这是我写的，有点投机取巧✌️，勉强能用。</p><p>链接：<a href="http://pan.baidu.com/s/1nuXLmAl" target="_blank" rel="noopener">http://pan.baidu.com/s/1nuXLmAl</a> 密码：yjvq</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为毕业设计选了个让自己一脸懵逼的题目，听同学说树莓派实现比较简单，所以我就花了4百大洋买了一个3B的板子和一个树莓派原装的摄像头（一百五左右，最后发现网上资料太少了!😭，而且只是搞下毕业设计，就不打算深究了，网上找个例子实现功能就可以了，不过拍的确实清晰）。好了，下面就
      
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="树莓派" scheme="http://yoursite.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="温湿度传感器" scheme="http://yoursite.com/tags/%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    
      <category term="毕业设计" scheme="http://yoursite.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>java之char数组输出</title>
    <link href="http://yoursite.com/2015/02/07/java%E4%B9%8Bchar%E6%95%B0%E7%BB%84%E8%BE%93%E5%87%BA/"/>
    <id>http://yoursite.com/2015/02/07/java之char数组输出/</id>
    <published>2015-02-07T02:37:46.000Z</published>
    <updated>2018-03-05T02:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先println方法对数组的处理是先转化为String类型，我们可以进入println源码看一下，我是创建了一个String数组进去看了下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(x);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先他都转化成了String，然后进入print方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        s = <span class="string">"null"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再进入write方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();<span class="comment">//确认输出流是否打开了</span></span><br><span class="line">            textOut.write(s);<span class="comment">//就是一个bufferWriter，写入到缓冲区</span></span><br><span class="line">            textOut.flushBuffer();<span class="comment">//刷新缓存区</span></span><br><span class="line">            charOut.flushBuffer();<span class="comment">//OutputStreamWriter</span></span><br><span class="line">            <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                out.flush();<span class="comment">//这里就是与char数组的却别，他直接把String s刷新到了控制台的输出流中，但是记住他没有和toString方法相关联</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们看看char数组的write方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> buf[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            textOut.write(buf);</span><br><span class="line">            textOut.flushBuffer();</span><br><span class="line">            charOut.flushBuffer();</span><br><span class="line">            <span class="keyword">if</span> (autoFlush) &#123;<span class="comment">//我们可以看到，他是把每个字符都写入到了控制台的输出流了。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.length; i++)</span><br><span class="line">                    <span class="keyword">if</span> (buf[i] == <span class="string">'\n'</span>)</span><br><span class="line">                        out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这是第二次遇到这问题了，但是之前没有非常明白，这里弄清楚记录一下，也供大家参考一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先println方法对数组的处理是先转化为String类型，我们可以进入println源码看一下，我是创建了一个String数组进去看了下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
