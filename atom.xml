<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天秤座</title>
  
  <subtitle>libra</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-29T11:16:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>colin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库索引之BTree</title>
    <link href="http://yoursite.com/2018/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%B9%8BBTree/"/>
    <id>http://yoursite.com/2018/03/29/数据库索引之BTree/</id>
    <published>2018-03-29T11:08:39.000Z</published>
    <updated>2018-03-29T11:16:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们看一些数据库索引文章的时候，避免不了会看到B-Tree或者B+Tree，那么什么是B-Tree呢？为什么数据库普遍喜欢这个数据结构呢？下面就从这两点说起</p><h6 id="什么是B-Tree"><a href="#什么是B-Tree" class="headerlink" title="什么是B-Tree"></a>什么是B-Tree</h6><p>B树最早接触时在严蔚敏的数据结构中了解到的，那么我们根据一张图来看看她给出的定义</p><img src="/2018/03/29/数据库索引之BTree/1.png"><blockquote><p>一颗m阶的B树，或为空树，或为满足一下特性的m叉树：</p><ol><li>书中每一个节点至多有m颗子树；</li><li>若根节点不是叶子节点，则至少有两颗子树；</li><li>除根节点之外的所有非终端节点至少有【m/2】颗子树；</li><li>所有的非终端节点中包含下列信息数据<img src="https://www.zhihu.com/equation?tex=%28n%2CA_%7B0%7D+%2CK_%7B1%7D%2CA_%7B1%7D%2CK_%7B2%7D+%2CA_%7B2%7D%2C...%2CK_%7Bn%7D%2CA_%7Bn%7D%29" alt="(n,A_{0} ,K_{1},A_{1},K_{2} ,A_{2},...,K_{n},A_{n})">，其中：<img src="https://www.zhihu.com/equation?tex=K_%7Bi%7D" alt="K_{i}">（<img src="https://www.zhihu.com/equation?tex=i%3D1%2C...%2Cn" alt="i=1,...,n">）为关键字，且<img src="https://www.zhihu.com/equation?tex=K_%7Bi%7D%3CK_%7Bi%2B1%7D" alt="K_{i}&lt;K_{i+1}">（<img src="https://www.zhihu.com/equation?tex=i%3D1%2C...%2Cn-1" alt="i=1,...,n-1">）；<img src="https://www.zhihu.com/equation?tex=A_%7Bi%7D" alt="A_{i}">（<img src="https://www.zhihu.com/equation?tex=i%3D0%2C...%2Cn" alt="i=0,...,n">）为指向子树根节点的指针，且指针<img src="https://www.zhihu.com/equation?tex=A_%7Bi-1%7D" alt="A_{i-1}">所指子树中的所有节点的关键字均小于<img src="https://www.zhihu.com/equation?tex=K_%7Bi%7D" alt="K_{i}">（<img src="https://www.zhihu.com/equation?tex=i%3D1%2C...%2Cn" alt="i=1,...,n">），<img src="https://www.zhihu.com/equation?tex=A_%7Bn%7D+" alt="A_{n} ">所指子树中所有节点的关键字均大于<img src="https://www.zhihu.com/equation?tex=K_%7Bn%7D+" alt="K_{n} ">，<img src="https://www.zhihu.com/equation?tex=n" alt="n">（<img src="https://www.zhihu.com/equation?tex=%5Clceil+m%2F2-1+%5Crceil+%5Cleq+n+%5Cleq+m-1" alt="\lceil m/2-1 \rceil \leq n \leq m-1">）为关键字的个数（或<img src="https://www.zhihu.com/equation?tex=n%2B1" alt="n+1">为子树个数）</li><li>所有的叶子节点都出现在同一层次上，并且不带信息（可以看作是外部节点或查找失败的节点，实际上这些节点不存在，指向这些节点的指针为空）。</li></ol></blockquote><p>从特性中我们看到：</p><blockquote><ol><li>B树是一个多叉树，而且是平衡树，关键字存放在整颗树中，性能等价于二分查找。</li><li>因为每个节点至少有M／2个儿子，所以可以保证树的深度不会过深，但是新增节点和删除节点也要保证这个特性，所以会出现节点的分裂与合并。</li></ol></blockquote><p>接下来我们聊聊B+树</p><p>其实B+树的出现正是应文件系统所需才出现的一种数据结构，他是B树的变种，他的定义和B树有区别也有联系：</p><img src="/2018/03/29/数据库索引之BTree/2.png"><blockquote><ol><li>有n颗子树的节点中含有n个关键字；</li><li>所有叶子节点中包含了全部关键字信息，及指向含有这些关键字记录的指针，且叶子节点本身依关键字的大小从小到大顺序连接；</li><li>所有的非终端节点可看成是索引部分，节点中仅含有其子树（根节点）中的最大或最小关键字；</li></ol></blockquote><h6 id="数据库为什么要用B树"><a href="#数据库为什么要用B树" class="headerlink" title="数据库为什么要用B树"></a>数据库为什么要用B树</h6><p>其实数据库不用索引也是可以的，但是索引是为了加快查询，这在OLADP（线上分析处理）的时候是很重要的。而索引其实就是一种数据结构，有hash索引，全文索引，B+Tree索引，其实就是不同的数据结构，我们现在只谈论为什么用BTree。在之前我们先学习两个东西：</p><ol><li>局部性原理：当一个数据被用到时，其附近的数据通常也会马上被用到</li><li>磁盘预读：即使使用了磁盘页中的一部分数据，磁盘也会把整个页读取给内存</li></ol><p>随着内存越来越大，很多时候我们都会做缓存，其实预读也是缓存。由于内存和磁盘的IO速度根本不在一个量级，在加上局部性原理，我们一般会按页读取（通常一页为4K）。数据库设计者把索引的每个节点都设计成一页，而且出度设置很大，这样就减少了深度，建设深度为d，那么一次查询最多进行d-1次IO就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们看一些数据库索引文章的时候，避免不了会看到B-Tree或者B+Tree，那么什么是B-Tree呢？为什么数据库普遍喜欢这个数据结构呢？下面就从这两点说起&lt;/p&gt;
&lt;h6 id=&quot;什么是B-Tree&quot;&gt;&lt;a href=&quot;#什么是B-Tree&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="底层原理" scheme="http://yoursite.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Paxos算法</title>
    <link href="http://yoursite.com/2018/01/03/Paxos%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/01/03/Paxos算法/</id>
    <published>2018-01-02T16:00:19.000Z</published>
    <updated>2018-03-12T16:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式一致性中Paxos算法是一个非常重要的算法，阿里实现的X-Paxos，腾讯的phxpaxos（开源）</p><h3 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h3><p>Paxos四个角色：</p><ul><li>Client：议题提出者</li><li>Proposer：提议者</li><li>Acceptor：投票者</li><li>Learner：决策者</li></ul><img src="/2018/01/03/Paxos算法/1.png" title="Basic Paxos"><p>图中只是显示一个提议的执行过程，步骤是</p><ol><li>Client（提议发起者）提出一个提议，交给一个Propser</li><li>这个Propser带着一个值（可以理解为id）去告诉所有的Acceptor</li><li>Acceptor看看自己的id，发现为空，然后就记录下Propser的id。</li><li>Propser第二次带着id和提议去找所有的Acceptor，那些记录的id还是自己的话，Acceptor就接受这个提议，记录下并告诉Learner</li><li>当Learner发现这一协议已经超过半数了，那么就代表通过了，然后把信息返回给Client</li></ol><p>从执行过程可以看到，朴素Pexos是一个2-Phase，第一阶段先去告诉Acceptor我的id，第二阶段才让Acceptor去接受协议。</p><blockquote><p>多Propser的时候要注意</p><ol><li>如果一个Propser携带的id比Acceptor记录的小，那么会被拒绝</li><li>如果Propser携带的id大于Acceptor的id，那么就覆盖Acceptor的id</li><li>如果Propser到达的Acceptor已经接受了某个协议，那么Propser就会把自己的协议改成Acceptor记录的协议</li></ol></blockquote><h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h3><p>Basic Paxos因为是2-Phase，所以延时很高，而且它最后只确定了一个值。而Multi Paxos正好解决了这两个问题。</p><img src="/2018/01/03/Paxos算法/2.png" title="Multi Paxos"><p>如图所示，Multi Paxos只有一个阶段，其实在Basic Paxos中第一个阶段只是为了防止多个提议照成的冲突，而真正验证是否一致性的是第二个阶段，当超过一半的都已经接受同一个提议，那么则个协议肯定通过了。</p><p>而之所以能去掉第一个阶段是因为只有一个Propser在提议，所以只要保证半数成功即可，因为是一个所以不能并发，而这个Propser的选取有的说是使用Basic Paxos来选举的，其实在Paxos原论文有一种更好的方式，就是Acceptor节点接受到其他节点的请求的话，执行一段时间的提交请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在分布式一致性中Paxos算法是一个非常重要的算法，阿里实现的X-Paxos，腾讯的phxpaxos（开源）&lt;/p&gt;
&lt;h3 id=&quot;Basic-Paxos&quot;&gt;&lt;a href=&quot;#Basic-Paxos&quot; class=&quot;headerlink&quot; title=&quot;Basic Pa
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="一致性" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
    
      <category term="一致性" scheme="http://yoursite.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>自定义线程池（二）</title>
    <link href="http://yoursite.com/2017/12/11/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/12/11/自定义线程池（二）/</id>
    <published>2017-12-11T09:38:30.000Z</published>
    <updated>2018-03-06T09:42:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇已经讲过一些线程池的概念，现在我们来自定义一个线程池，实现的不是一般，就是一个个人理解的线程池实现，仅供参考。</p><ol><li><p>创建变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程状态，空闲，运行中，阻塞，结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">enum</span> WorkerState &#123;FREE, RUNNABLE, BLOCKED,TERMINATED;&#125;</span><br><span class="line"><span class="comment">// 线程池是否被销毁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroy = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CORE_THREAD_SIZE = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THREAD_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 任务队列容器,也可以用Queue&lt;Runnable&gt; 遵循 FIFO 规则</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> LinkedList&lt;Runnable&gt; TASK_QUEUE = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">// 设置它的边界值为11</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TASK_QUEUE_MAX_SIZE = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 线程容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Worker&gt; WORKERS = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><blockquote><ol><li>WorkerState：线程状态，一个线程新创建的时候为FREE，工作的时候为RUNNABLE，处于阻塞状态的时候为BLOCK（意味着当前任务队列没有任务了），而TERMINATED表示当前线程结束</li><li>destroy：线程池状态，表示当前线程是否已经销毁，只有执行了shutdown方法才会销毁线程池，并发情况下要保证可见性</li><li>TASK_QUEUE_MAX_SIZE：任务阻塞队列的边界值</li></ol></blockquote></li><li><p>编写submit方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (destroy) &#123;</span><br><span class="line">        System.out.println(<span class="string">"线程池已经销毁了，抛出异常！这里用日志代替"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (TASK_QUEUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WORKERS.size() &lt; CORE_THREAD_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">"核心线程数还没有满，直接创建线程"</span>);</span><br><span class="line">            createWorkerTask();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TASK_QUEUE.size() &lt; TASK_QUEUE_MAX_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">"核心线程数已满，但是队列没有满，把任务加到队列"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WORKERS.size() &lt; MAX_THREAD_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">"核心线程数,队列满了，但是没有达到最大线程数，我们接着创建线程"</span>);</span><br><span class="line">            createWorkerTask();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WORKERS.size() &gt;= MAX_THREAD_SIZE) &#123;</span><br><span class="line">            System.out.println(<span class="string">"达到了最大线程数，应该执行拒绝策略，这里我们就直接返回了"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"情况未知"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入任务队列</span></span><br><span class="line">        TASK_QUEUE.addLast(runnable);</span><br><span class="line">        <span class="comment">// 唤醒所有线程</span></span><br><span class="line">        TASK_QUEUE.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>没有一个任务，我们都是通过submit交给线程池去处理的，先判断是否达到核心线程数，没有的话直接创建，如果核心线程数满了，就往队列里加，队列也满了就新建线程，如果达到最大线程数，就拒绝，这里有一点改变就是不管哪一种，我们都把人物放到任务队列中，让线程去任务队列里面取。</p></blockquote></li><li><p>创建线程方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void createWorkerTask() &#123;</span><br><span class="line">    Worker worker = new Worker();</span><br><span class="line">    worker.workerState = WorkerState.FREE;</span><br><span class="line">    WORKERS.add(worker);</span><br><span class="line">    worker.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程创建之初，为空闲状态，并添加进线程集合中</p></blockquote></li><li><p>创建线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WorkerState workerState;</span><br><span class="line">    <span class="comment">// 线程编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line">    <span class="comment">// 生成线程名</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> String <span class="title">nextThreadName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thread-"</span> + (++threadInitNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    Worker() &#123;</span><br><span class="line">        nextThreadName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启了一个新的线程------&gt;"</span> + threadInitNumber);</span><br><span class="line">        Runnable targer;</span><br><span class="line">        OUTER:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.workerState != WorkerState.TERMINATED) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TASK_QUEUE) &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.workerState == WorkerState.FREE &amp;&amp; TASK_QUEUE.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.workerState = WorkerState.BLOCKED;</span><br><span class="line">                        TASK_QUEUE.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">break</span> OUTER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                targer = TASK_QUEUE.removeFirst();</span><br><span class="line">                System.out.println(<span class="string">"处理任务"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.workerState = WorkerState.RUNNABLE;</span><br><span class="line">                targer.run();</span><br><span class="line">                <span class="keyword">this</span>.workerState = WorkerState.FREE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workerState = WorkerState.TERMINATED;</span><br><span class="line">        <span class="keyword">this</span>.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了方便观看，我们给线程指定编号，如果当前线程没有关闭的话，先去判断队列是否为空且本身的状态是空闲的话，我们就让他wait，等新来的任务再去唤醒，如果获取到了我们就处理这个任务，并把他从队列的头部拿出来</p></blockquote></li><li><p>关闭线程池方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = WORKERS.size();</span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : WORKERS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (worker.workerState == WorkerState.BLOCKED) &#123;</span><br><span class="line">                worker.close();</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.destroy = <span class="keyword">true</span>;</span><br><span class="line">    TASK_QUEUE.clear();</span><br><span class="line">    WORKERS.clear();</span><br><span class="line">    System.out.println(<span class="string">"线程池已经关闭！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>等所有线程的任务都完成了以后才关闭线程，同时把线程池状态标记为销毁，并清空任务队列和线程集合。</p></blockquote></li><li><p>使用run()来控制释放线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!destroy) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (WORKERS) &#123;</span><br><span class="line">                Iterator&lt;Worker&gt; iterator = WORKERS.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    Worker worker = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (WORKERS.size() &gt; CORE_THREAD_SIZE &amp;&amp; </span><br><span class="line">                        TASK_QUEUE.size() &lt; TASK_QUEUE_MAX_SIZE) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (worker.workerState != WorkerState.RUNNABLE &amp;&amp; worker.workerState != WorkerState.TERMINATED) &#123;</span><br><span class="line">                            worker.close();</span><br><span class="line">                            iterator.remove();</span><br><span class="line">                            System.out.println(<span class="string">"[回收了一个线程]"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每隔3秒去遍历一下所有的线程，如果线程数大于核心线程数，且任务队列不满的话，就删除线程，知道和核心线程数一样</p></blockquote></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    DemoThreadPool demoThreadPool = <span class="keyword">new</span> DemoThreadPool();</span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">5</span>).forEach(i -&gt;</span><br><span class="line">            demoThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.printf(<span class="string">"[线程] - [%s] 开始工作...\n"</span>,        </span><br><span class="line">                                  Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2_000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">"[线程] - [%s] 工作完毕...\n"</span>, </span><br><span class="line">                                  Thread.currentThread().getName());</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    IntStream.range(<span class="number">0</span>, <span class="number">30</span>).forEach(i -&gt;</span><br><span class="line">            demoThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.printf(<span class="string">"[线程] - [%s] 开始工作...\n"</span>, </span><br><span class="line">                                  Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2_000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">"[线程] - [%s] 工作完毕...\n"</span>, </span><br><span class="line">                                  Thread.currentThread().getName());</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line"><span class="comment">//        demoThreadPool.shutdown();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了观察状态，我们先一下子创建5个任务，这个时候他会先创建2个线程，然后把3个放到队列里，因为没有满，所以这两个线程就可以应付，但是当一下30个的时候，会发生拒绝，然后过了峰值以后，多余的线程就会销毁。</p></blockquote><p>实现的可能不好，但是我理解的就是这样，源码在<a href="https://github.com/colin-xun/threadpool上，欢迎给我点:star" target="_blank" rel="noopener">https://github.com/colin-xun/threadpool上，欢迎给我点:star</a>:</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇已经讲过一些线程池的概念，现在我们来自定义一个线程池，实现的不是一般，就是一个个人理解的线程池实现，仅供参考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建变量&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="java高级" scheme="http://yoursite.com/categories/java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>自定义线程池（一）</title>
    <link href="http://yoursite.com/2017/12/09/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/12/09/自定义线程池（一）/</id>
    <published>2017-12-09T08:17:23.000Z</published>
    <updated>2018-03-05T10:15:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我们自定义线程池之前，先预备一点前置知识</p><ul><li>为什么要使用线程池？</li></ul><ol><li>New Thread这种方式性能差</li><li>缺乏统一管理，循环创建会照成OOM</li><li>功能单一</li></ol><p>对应的就是线程池的优点，JAVA1.5出来的Concurrent包里面提供了四种创建线程池的方法，我们可以直接创建，但阿里Java开发手册有这么一条</p><blockquote><p>【强制】线程池不允许使用 Executors 去创建，而是通过ThreadPoolExecutor 的方式</p></blockquote><p>这样的好处就强制开发者去了解线程池的创建原理，从而避免资源耗尽的风险，而且Executors中四种线程池创建方式其实都依赖于ThreadPollExecutor这个类的构造。</p><ul><li>线程池概念</li></ul><img src="/2017/12/09/自定义线程池（一）/1.png" title="关系图"><p>从图中可以看到各个类和接口的关系，同时可以看到Executors和其他类或接口没有什么直接关系，我们可以把他当成一个线程池工厂，用来创建四种线程池。</p><p>先说下ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>corePoolSize：核心线程数大小</p><p>maximumPoolSize：线程池最大线程数</p><p>keepAliveTime：当线程数大于核心时，清除空闲keepAliveTime时间的线程</p><p>unit：时间单位</p><p>workQueue：存储等待任务的队列</p><p>threadFactory：线程工厂</p><p>handler：拒绝策略</p></blockquote><p>刚创建的线程池是没有任何线程的，当过来一个任务，就启动一个线程去执行，再过来一个还创建一个新的线程，即便之前的已经空闲了，当线程池达到核心线程数的话，如果没有空闲线程，就把新加进来的任务放到阻塞队列，如果阻塞队列是有边界的话，到达边界以后就会去创建新的线程，接下来就会出现两种情况：</p><ol><li>如果任务不再来了，那么就会把空闲keepAliveTime时间的线程给移除掉</li><li>如果任务接着来，并且已经达到了最大线程数，那么就要执行拒绝策略了</li></ol><p>其中等待队列有多种ArrayBlockingQueue，LinkedBlockingQueue，LinkedBlockingDeque，SynchronousQueue，根据具体情况而定。</p><p>拒绝策略也有很多种</p><ol><li>AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。 (默认)</li><li>DiscardPolicy：也是丢弃任务，但是不抛出异常。</li><li>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>CallerRunsPolicy：由调用线程处理该任务</li></ol><ul><li>四种创建线程池的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建一个单线程，你看名字里面都没有ThreadPool:smile:，如果这个线程死了，他会创建一个新的线程来替代。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个线程的特点从等待队列就可以看出来，这个队列根本不存储数据，只是做一个通道，一边进一边出。最大线程数为Integer.MAX_VALUE,也就是过来一个任务我就创建一个线程，当线程数大于任务数的时候就去回收那些空闲超过60秒的线程。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        nThreads, nThreads,</span><br><span class="line">    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个线程池核心线程和最大线程数相等，也就是说，过来一个任务，就直接创建一个线程，等到了最大线程数，你看keepAliveTime为0，所以就是不管线程使用不适用都不回收，如果线程挂了的话会重新创建一个。为了不然频繁丢弃任务，这里使用了一个无界链表队列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(</span><br><span class="line">          corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">      <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个线程池的特点从名字就可以看出来，定期线程池，也就是任务会定期执行，这个定期是在他调用schedule方法的时候，就像一个Timer定时器一样，而他的实现主要是靠DelayedWorkQueue这个延迟队列，他规定只有到达规定延迟时间以后才能获取里面的元素</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我们自定义线程池之前，先预备一点前置知识&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么要使用线程池？&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;New Thread这种方式性能差&lt;/li&gt;
&lt;li&gt;缺乏统一管理，循环创建会照成OOM&lt;/li&gt;
&lt;li&gt;功能单一&lt;/li&gt;
&lt;/ol&gt;
&lt;
      
    
    </summary>
    
      <category term="java高级" scheme="http://yoursite.com/categories/java%E9%AB%98%E7%BA%A7/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>String之intern函数</title>
    <link href="http://yoursite.com/2017/12/04/String%E4%B9%8Bintern%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/12/04/String之intern函数/</id>
    <published>2017-12-04T03:36:18.000Z</published>
    <updated>2018-03-12T16:10:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>在讲解正式内容前，先来看看JVM的内存模型，以及1.6和1.7还有1.8的内存模型有什么不同。</p><img src="/2017/12/04/String之intern函数/1.png" title="JVM内存图"><blockquote><p>虚拟机栈里面存放的就是一个一个的栈帧（栈帧是用来存储数据和存储部分过程结果的数据结构），而且只有一个活跃的栈帧，也就是栈顶元素</p><p>本地方法栈根据名字就知道他是为本地方法服务的（本地方法只是用java语言定义了，但是具体实现可能就是别的语言了）,他里面存放的就是本地方法帧，用于调用执行本地方法</p><p>程序计数器里面存放的内容可以理解为当前字节码的执行地址，用以完成分支，循环，跳转，异常处理，线程恢复等基础功能</p><p>堆内存：图1所画的是1.6时候的，这时堆中还只有新生代和老年代，新生代占1/3，老年代占2/3，Eden占新生代的8/10（所以新生代实际有效空间为9/10）</p><p>方法区：方法区是堆的逻辑组成部分，用来存放类的基础信息，可以分为以下几类，运行时常量，域信息，方法信息，静态变量等信息。</p></blockquote><p>同时通过上面的图我们可以看到：虚拟机栈，本地方法栈，程序计数器都是线程私有的，而堆和方法区是线程共有的。</p><hr><p>在1.6中PermGen（永久代）存放在方法区中<br>在1.7中PermGen（永久代）中的符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。<br>在1.8中方法区已经没有了，出来了一个Metaspace（元空间），其实和永久代一样，都是对方法区的实现，但是元空间已经不在JVM虚拟机里面了，而是在虚拟机外面的内存空间</p><blockquote><p>那么为什么要移除方法区呢？个人认为是方法区是在启动时确认的，这样会照成内存溢出，而且永久代的回收实现相对比较麻烦</p></blockquote><hr><p>终于可以讲正式内容了</p><p>首先看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String s1 = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">       s1.intern();</span><br><span class="line">       String s2 = <span class="string">"1"</span>;</span><br><span class="line">       System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">       String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">       s3.intern();</span><br><span class="line">       String s4 = <span class="string">"11"</span>;</span><br><span class="line">       System.out.println(s3 == s4);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdk6 下<span class="keyword">false</span> <span class="keyword">false</span></span><br><span class="line">jdk7 下<span class="keyword">false</span> <span class="keyword">true</span></span><br><span class="line">jdk8 下<span class="keyword">false</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure><img src="/2017/12/04/String之intern函数/2.png" title="1.6内存图"><blockquote><p>第一行，new String（“1”）会现在String常量池里面创建一个1的常量，然后在堆里面创建一个String对象，内容指向常量池中的1，然后s1只想堆中对象</p><p>第二行，s1.intern的作用的去常量池里面查看有没有1这个变量，如果没有的话创建</p><p>第三行String s2 = “1”这种创建方法，会直接让s2指向常量池中的1</p><p>第四行，因为s1指向的是堆中地址，s2指向的是常量池中地址，所以肯定为false</p><p>第五行首先和第一行一样，创建两个匿名对象，然后在堆内存中创建一个String对象，对象的值为11，然后让s3指向这个对象</p><p>第六行，查看常量池没有11，创建，并让堆中对象指向该地址</p><p>第七行，s4指向常量池中11</p><p>第八行，因为s3指向的是堆中地址，s4指向的是常量池中地址，所以为false</p></blockquote><p>那么为什么1.7和1.8输出为true呢？这就是内存模型改变照成的</p><img src="/2017/12/04/String之intern函数/3.png" title="1.7内存图"><blockquote><p>注意看箭头指向</p><p>前面已经说过，在1.6以后，已经把一部分内容移动到了heap中，而String poll就放到了堆中，那么既然都在堆中，没必要创建两份对象吧？</p><p>所以第六行的改变就变成了，查看String poll中没有11这个变量，然后就在常量池中开辟一片空间，然后让他指向堆内存的对象（这样一个堆里面，同样的对象只存在一个，别的都是引用）</p><p>所以第八行就成了，s3的值为堆中地址，s4也为堆中地址，所以为true</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在讲解正式内容前，先来看看JVM的内存模型，以及1.6和1.7还有1.8的内存模型有什么不同。&lt;/p&gt;
&lt;img src=&quot;/2017/12/04/String之intern函数/1.png&quot; title=&quot;JVM内存图&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟机栈里面存放
      
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>session共享解决方案</title>
    <link href="http://yoursite.com/2017/10/09/session%E5%85%B1%E4%BA%AB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2017/10/09/session共享解决方案/</id>
    <published>2017-10-09T05:43:54.000Z</published>
    <updated>2018-03-09T05:48:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>用户通过浏览器访问服务器的时候，服务器会自动产生session，用来存放用户信息，登录信息等内容，在分布式的系统中，如何保证session的一致性呢？</p><ul><li><p>方法一：session同步</p><p>这个很好解释，也就是每新生成一个session，我们都把他同步到所有的服务器上面，这样每台服务器都有所有用户的session了，这是一种解决方法</p><p>优点：实现思路简单</p><p>缺点：  </p><ol><li>占用带宽，也就是每次都要去同步session，当服务器多的时候情况会很明显</li><li>占用内存，每台服务器都要存储所有的session，当session多的时候情况会很明显</li></ol></li><li><p>方法二：客户端存储</p><p>用客户端来存放用户信息，登录信息等内容，下次请求的时候携带过来就行了，也是一种实现方法</p><p>优点：服务端不用存储</p><p>缺点：</p><ol><li>安全性下降：cookie容易被窃取</li><li>存储数据量小，不同浏览器允许的cookie大小有限。</li></ol></li><li><p>方法三：一致性hash</p><p>使用一致性hash算法计算出每个session存放的服务器，例如使用IP来做一致性hash，那么这个IP对应的session存放在哪一台服务器就确定了</p><p>优点：</p><ol><li>工作量小，不需要更改代码，只要配置nginx就可以了</li><li>支持水平扩展</li></ol><p>缺点：</p><ol><li>当新水平扩展的时候，要从新计算hash值，用户需要重新登录</li><li>服务器重启，数据丢失</li></ol></li><li><p>方法四：后台统一存储</p><p>把session存放到数据库或缓存中</p><p>优点：</p><ol><li>安全性高：即便重启了数据依然存在</li><li>水平扩展：因为session是单独存储的，所以不影响水平扩展</li></ol><p>缺点：</p><ol><li>代码改动量大：当然如果一开始就使用的话，也是很简单的</li><li>增加了一次服务调用</li></ol></li></ul><p>目前公司在使用的是redis中的session共享，使用redis的好处是速度快而且支持持久化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用户通过浏览器访问服务器的时候，服务器会自动产生session，用来存放用户信息，登录信息等内容，在分布式的系统中，如何保证session的一致性呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法一：session同步&lt;/p&gt;
&lt;p&gt;这个很好解释，也就是每新生成一个session，
      
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="一致性" scheme="http://yoursite.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="session" scheme="http://yoursite.com/tags/session/"/>
    
      <category term="共享" scheme="http://yoursite.com/tags/%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>拜占庭容错算法（PBFT）</title>
    <link href="http://yoursite.com/2017/09/09/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%AE%97%E6%B3%95%EF%BC%88PBFT%EF%BC%89/"/>
    <id>http://yoursite.com/2017/09/09/拜占庭容错算法（PBFT）/</id>
    <published>2017-09-09T08:31:38.000Z</published>
    <updated>2018-03-09T08:37:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>拜占庭将军问题反映到现实情况就是：在一个不可靠的信道上，如何保证信息传递的一致性。</p><p>解决方法：拜占庭容错算法（PBFT），分为三个阶段：预准备（pre-prepare）、准备（prepare）、确认（commit）</p><img src="/2017/09/09/拜占庭容错算法（PBFT）/1.jpg" title="流程图"><p>从图中可以看到C发出一个请求，四个信道中3号信道是有问题的。</p><p>第一步：C发出请求，到了0（可以是任意信道）</p><p>第二步：0在预准备阶段广播到所有节点，其中3有故障未到达</p><p>第三步：准备阶段，如果收到的请求超过一定数量，发出广播</p><p>第四部：确认阶段，如果收到的请求超过一定数量，对C进行反馈</p><p>在N &gt;= 3F + 1的情况下一致性是可以用这种方法解决的，N是总计算机数，F是有问题的计算机数</p><img src="/2017/09/09/拜占庭容错算法（PBFT）/2.png"><p>可以看出在错误节点小于1/3的时候，这种方法时可行的。央行使用的就是PBFT。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;拜占庭将军问题反映到现实情况就是：在一个不可靠的信道上，如何保证信息传递的一致性。&lt;/p&gt;
&lt;p&gt;解决方法：拜占庭容错算法（PBFT），分为三个阶段：预准备（pre-prepare）、准备（prepare）、确认（commit）&lt;/p&gt;
&lt;img src=&quot;/2017/09
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="一致性" scheme="http://yoursite.com/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>java值传递和引用传递</title>
    <link href="http://yoursite.com/2017/01/23/java%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2017/01/23/java值传递和引用传递/</id>
    <published>2017-01-23T06:09:58.000Z</published>
    <updated>2018-03-12T16:10:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道面试题<br>之前被问到过，但是过后也没好好想想，今天有朋友问到这个，查过资料以后总结下<br>先看一段代码：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"A"</span>;  </span><br><span class="line">        change(str);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        </span><br><span class="line">        Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">        changeb(i);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">        changed(j);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        </span><br><span class="line">        Stu stu = <span class="keyword">new</span> Stu(<span class="string">"colin"</span>);</span><br><span class="line">        changec(stu);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changed</span><span class="params">(Integer j)</span> </span>&#123;</span><br><span class="line">        j = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changec</span><span class="params">(Stu stu)</span> </span>&#123;</span><br><span class="line">        stu.name = <span class="string">"libra"</span>;</span><br><span class="line"><span class="comment">//        stu = new Stu("libra");</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeb</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">        i = <span class="keyword">new</span> Integer(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stu&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p></p><h5>结果</h5><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">Stu&#123;name=<span class="string">'wtx'</span>&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><h5>个人理解：</h5><br>java中传递方式分为值传递和引用传递<br>值传递：基本类型(byte–short–int–long–float–double–boolean–char)<br>引用传递：类类型，接口类型，数组<p></p><p></p><h6>例子一：String</h6><br><img src="/2017/01/23/java值传递和引用传递/1.png" title="java内存图"><br>String是在常量池中的，这些无所谓，有所谓的是引用传递传递的是地址，A的地址是0x1101现在把0x1101传递过去，让实参str接受，这时候str也指向了0x1101，这时候修改实参str的指向，只是修改了实参的指向，没有修改外面str的指向，所有输出为A<p></p><p></p><h6>例子二：Integer，Double包装类</h6><br>这些包装类里面没有修改值的操作，而且是final类型的，所以我们修改值的时候不是在原来的基础上修改，所以输出10<p></p><p></p><h6>例子三：基本类型</h6><br>基本类型就是值传递，不涉及引用，不修改外面值<p></p><p></p><h6>例子四：修改对象值</h6><br>对于例子四，如果使用第一行代码的话，我们是在原对象中修改，故会改变外面的值，但是如果我们是用第二种，那只是改变了内部引用，不影响外面值的变化<p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道面试题&lt;br&gt;之前被问到过，但是过后也没好好想想，今天有朋友问到这个，查过资料以后总结下&lt;br&gt;先看一段代码：&lt;br&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>树莓派3B-DHT11-Yeelink云平台（实现温湿度远程监控）</title>
    <link href="http://yoursite.com/2015/07/09/%E6%A0%91%E8%8E%93%E6%B4%BE3B-DHT11-Yeelink%E4%BA%91%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%B8%A9%E6%B9%BF%E5%BA%A6%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7%EF%BC%89/"/>
    <id>http://yoursite.com/2015/07/09/树莓派3B-DHT11-Yeelink云平台（实现温湿度远程监控）/</id>
    <published>2015-07-09T02:37:46.000Z</published>
    <updated>2018-03-05T03:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为毕业设计选了个让自己一脸懵逼的题目，听同学说树莓派实现比较简单，所以我就花了4百大洋买了一个3B的板子和一个树莓派原装的摄像头（一百五左右，最后发现网上资料太少了!😭，而且只是搞下毕业设计，就不打算深究了，网上找个例子实现功能就可以了，不过拍的确实清晰）。好了，下面就说下怎么实现云平台实时监控温湿度把。其中有投机取巧的部分。其实我说的所有都只是一种方法，大家可以去尝试别的，下面就不赘述了，直接写过程。</p><ul><li>装系统</li></ul><p>装系统的话，直接去官网下载就行，毕竟用的树莓派，我就下了raspbian，带桌面（毕竟小白）这是下载链接<a href="https://downloads.raspberrypi.org/raspbian_latest" target="_blank" rel="noopener">https://downloads.raspberrypi.org/raspbian_latest</a></p><p>同时需要一个写入工具，我当时应该不是在官网下的，这是链接，速度挺快，下载完解压就行<a href="http://124.202.164.7/files/4125000005975BAB/vzidc.newhua.com/down/Win32DiskImager-0.9.5-binary.zip" target="_blank" rel="noopener">http://124.202.164.7/files/4125000005975BAB/vzidc.newhua.com/down/Win32DiskImager-0.9.5-binary.zip</a></p><p>然后需要一张4g以上的sd卡，反正我用的8g，我用的就是很早以前手机里的内存卡，同时需要一个读卡器，打开读写工具，然后把解压后的img系统文件写入到内存卡，就可以了</p><ul><li>登录树莓派</li></ul><p>第一次登录用ssh工具，首先你需要知道局域网给你的树莓派分配的IP地址，可以使用一个端口扫描工具，看看哪儿22端口是开放的，然后xshell链接</p><ul><li>显示图形界面</li></ul><p>我也不先配置别的了，先让大家看看图形界面吧，上vncviewer下载客户端，然后在xshell输入sudo apt-get install tightvncserver然后等读码完成，然后输入vncserver，接下来它让你设置密码，我设置12345678，然后确认再输入一次，接着打开vncviewer，在地址栏输入树莓派ip:1回车，然后输入12345678，回车就可以看到图形界面了</p><ul><li>树莓派连接上无线网路</li></ul><p>因为树莓派没有自带vim，所以我就先安装了vim，命令式sudo apt-get install vim</p><p>然后sudo vim /etc/network/interfaces 然后修改成下列样式</p><pre><code>auto loiface loinet loopbackifaceeth0 inet dhcpautowlan0allow-hotplugwlan0ifacewlan0 inet dhcp      wpa-ssid 要连入的WiFi名      wpa-psk WiFi密码</code></pre><p>然后sudo /etc/init.d/networking restart 但是这时候会分配一个新的ip，然后xshell创建一个新的连接就行了</p><p>修改配置</p><p>这是树莓派3B的界面，别的修改项含义可以参考</p><p><a href="http://blog.csdn.net/xdw1985829/article/details/38816375" target="_blank" rel="noopener">http://blog.csdn.net/xdw1985829/article/details/38816375</a></p><p>，我修改了第一项，让文件系统覆盖整个sd卡，同时修改了时区，如果不修改时区的话，接下来上传的数据时间不正确</p><p>安装WiringPi</p><p>sudo apt-get install wiringPi 安装完可以测试一下gpio readall然后会显示一些东西就证明可以了</p><p>接下来就是程序和怎么连接到yeelink上了</p><p>下载我整理好的程序，test.c是源文件可以使用gcc编译一下，编译命令式gcc –Wall –o 输出的文件名  编译的文件名 –lwiringPi 然后生成一个你要生成的文件名</p><p>接下来修改shell脚本,Yeelink教程网上很多，我就不介绍了，得到两个传感器的URL就行，还有你的API key，替换成你的API key和URL，同时还有你编译.c生成的文件的路径</p><p>这是我写的，有点投机取巧✌️，勉强能用。</p><p>链接：<a href="http://pan.baidu.com/s/1nuXLmAl" target="_blank" rel="noopener">http://pan.baidu.com/s/1nuXLmAl</a> 密码：yjvq</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为毕业设计选了个让自己一脸懵逼的题目，听同学说树莓派实现比较简单，所以我就花了4百大洋买了一个3B的板子和一个树莓派原装的摄像头（一百五左右，最后发现网上资料太少了!😭，而且只是搞下毕业设计，就不打算深究了，网上找个例子实现功能就可以了，不过拍的确实清晰）。好了，下面就
      
    
    </summary>
    
      <category term="嵌入式" scheme="http://yoursite.com/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="树莓派" scheme="http://yoursite.com/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="温湿度传感器" scheme="http://yoursite.com/tags/%E6%B8%A9%E6%B9%BF%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    
      <category term="毕业设计" scheme="http://yoursite.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>java之char数组输出</title>
    <link href="http://yoursite.com/2015/02/07/java%E4%B9%8Bchar%E6%95%B0%E7%BB%84%E8%BE%93%E5%87%BA/"/>
    <id>http://yoursite.com/2015/02/07/java之char数组输出/</id>
    <published>2015-02-07T02:37:46.000Z</published>
    <updated>2018-03-05T02:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先println方法对数组的处理是先转化为String类型，我们可以进入println源码看一下，我是创建了一个String数组进去看了下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(x);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先他都转化成了String，然后进入print方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        s = <span class="string">"null"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再进入write方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();<span class="comment">//确认输出流是否打开了</span></span><br><span class="line">            textOut.write(s);<span class="comment">//就是一个bufferWriter，写入到缓冲区</span></span><br><span class="line">            textOut.flushBuffer();<span class="comment">//刷新缓存区</span></span><br><span class="line">            charOut.flushBuffer();<span class="comment">//OutputStreamWriter</span></span><br><span class="line">            <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                out.flush();<span class="comment">//这里就是与char数组的却别，他直接把String s刷新到了控制台的输出流中，但是记住他没有和toString方法相关联</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们看看char数组的write方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> buf[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            textOut.write(buf);</span><br><span class="line">            textOut.flushBuffer();</span><br><span class="line">            charOut.flushBuffer();</span><br><span class="line">            <span class="keyword">if</span> (autoFlush) &#123;<span class="comment">//我们可以看到，他是把每个字符都写入到了控制台的输出流了。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buf.length; i++)</span><br><span class="line">                    <span class="keyword">if</span> (buf[i] == <span class="string">'\n'</span>)</span><br><span class="line">                        out.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这是第二次遇到这问题了，但是之前没有非常明白，这里弄清楚记录一下，也供大家参考一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先println方法对数组的处理是先转化为String类型，我们可以进入println源码看一下，我是创建了一个String数组进去看了下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
